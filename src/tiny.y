/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>
#include "tree.h"

// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

//reference to the AST to build
extern PROG *program;

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}

%code requires
{
	#include "tree.h"
}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
	int intval;
    float floatval;
	char *string;
    EXP *expval;
    STM *stmtval;
    STMS *stmtsval;
    DECL *declval;
    DECLS *declsval;
    PROG *progval;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can be defined per directive by using a list
 * of identifiers separated by spaces.
 */

//types for terminals 
%token <intval> tINTVAL
%token <floatval> tFLOATVAL
%token <intval> tBOOLVAL
%token <string> tIDENTIFIER 
%token <string> tSTRINGVAL
%token tOR
%token tAND 
%token tNEQ
%token tEQ
%token tVAR
%token tINT
%token tFLOAT
%token tSTRING
%token tBOOLEAN
%token tWHILE
%token tIF
%token tELSE
%token tREAD
%token tPRINT

//types for non-terminals
%type <expval> exp
%type <stmtval> stmt
%type <declval> decl
%type <stmtsval> stmts
%type <declsval> decls
%type <progval> prog

/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */
%left tOR
%left tAND 
%left tEQ tNEQ
%left '+'
%left '*' '/'
%left '-'
%left '!' 
/* Start token (by default if this is missing it takes the first production */
%start prog

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */
%% 

exp : tIDENTIFIER { $$ = makeEXPid($1, @1.first_line); }
    | tINTVAL { $$ = makeEXPint($1, @1.first_line); }
    | tFLOATVAL { $$ = makeEXPfloat($1, @1.first_line); }
    | tBOOLVAL { $$ = makeEXPbool($1, @1.first_line); }
    | tSTRINGVAL { $$ = makeEXPstring($1, @1.first_line); }
    | exp '*' exp { $$ = makeEXPtimes($1, $3, @2.first_line); }
    | exp '/' exp { $$ = makeEXPdiv($1, $3, @2.first_line); }
    | exp '+' exp { $$ = makeEXPplus($1, $3, @2.first_line); }
    | exp '-' exp { $$ = makeEXPminus($1, $3, @2.first_line); }
    | exp tOR exp { $$ = makeEXPor($1, $3, @2.first_line); }
    | exp tAND exp { $$ = makeEXPand($1, $3, @2.first_line); }
    | '!' exp { $$ = makeEXPbang($2, @1.first_line); }
    | '-' exp { $$ = makeEXPnegate($2, @1.first_line); }
    | exp tEQ exp { $$ = makeEXPequals($1, $3, @2.first_line); }
    | exp tNEQ exp { $$ = makeEXPneq($1, $3, @2.first_line); }
    | '(' exp ')' { $$ = makeEXPparenthesis($2, @2.first_line); }
    ;

stmt : tIDENTIFIER '=' exp ';' { $$ = makeSTMassign($1, $3, @1.first_line); }
    | tREAD tIDENTIFIER ';' { $$ = makeSTMread($2, @1.first_line); }
    | tPRINT exp ';' { $$ = makeSTMprint($2, @1.first_line); }
    | tIF exp '{' stmts '}' { $$ = makeSTMif($2, $4, NULL, @1.first_line); }
    | tIF exp '{' stmts '}' tELSE '{' stmts '}' { $$ = makeSTMif($2, $4, $8, @1.first_line); }
    | tWHILE exp '{' stmts '}' { $$ = makeSTMwhile($2, $4, @1.first_line); }
    ;

stmts : stmt stmts { $$ = makeSTMS($1, $2); }
    | { $$ = NULL; }
    ;

decl : tVAR tIDENTIFIER ':' tINT '=' exp ';' { $$ = makeDECLint($2, $6, @2.first_line); }
    | tVAR tIDENTIFIER ':' tFLOAT '=' exp ';' { $$ = makeDECLfloat($2, $6, @2.first_line); }
    | tVAR tIDENTIFIER ':' tSTRING '=' exp ';' { $$ = makeDECLstring($2, $6, @2.first_line); }
    | tVAR tIDENTIFIER ':' tBOOLEAN '=' exp ';' { $$ = makeDECLbool($2, $6, @2.first_line); }
    ;

decls : decl decls { $$ = makeDECLS($1, $2); }
    | { $$ = NULL; }
    ;

prog : decls stmts { $$ = makePROG($1, $2); };


%%
